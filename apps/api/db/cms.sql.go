// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cms.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMedia = `-- name: CreateMedia :one
INSERT INTO media (
  tenant_id, filename, url, mime_type, size_bytes
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING id, tenant_id, filename, url, mime_type, size_bytes, created_at
`

type CreateMediaParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	Filename  string      `json:"filename"`
	Url       string      `json:"url"`
	MimeType  pgtype.Text `json:"mime_type"`
	SizeBytes pgtype.Int8 `json:"size_bytes"`
}

func (q *Queries) CreateMedia(ctx context.Context, arg CreateMediaParams) (Medium, error) {
	row := q.db.QueryRow(ctx, createMedia,
		arg.TenantID,
		arg.Filename,
		arg.Url,
		arg.MimeType,
		arg.SizeBytes,
	)
	var i Medium
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Filename,
		&i.Url,
		&i.MimeType,
		&i.SizeBytes,
		&i.CreatedAt,
	)
	return i, err
}

const createPage = `-- name: CreatePage :one
INSERT INTO pages (
  tenant_id, title, slug, content_json, status
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING id, tenant_id, title, slug, content_json, status, created_at, updated_at
`

type CreatePageParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	Title       string      `json:"title"`
	Slug        string      `json:"slug"`
	ContentJson []byte      `json:"content_json"`
	Status      pgtype.Text `json:"status"`
}

func (q *Queries) CreatePage(ctx context.Context, arg CreatePageParams) (Page, error) {
	row := q.db.QueryRow(ctx, createPage,
		arg.TenantID,
		arg.Title,
		arg.Slug,
		arg.ContentJson,
		arg.Status,
	)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Title,
		&i.Slug,
		&i.ContentJson,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO posts (
  tenant_id, title, slug, content_json, excerpt, status, published_at, author_id
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, tenant_id, title, slug, content_json, excerpt, status, published_at, author_id, created_at, updated_at, sector, tags, meta_description, custom_meta_tags, og_image_url
`

type CreatePostParams struct {
	TenantID    pgtype.UUID        `json:"tenant_id"`
	Title       string             `json:"title"`
	Slug        string             `json:"slug"`
	ContentJson []byte             `json:"content_json"`
	Excerpt     pgtype.Text        `json:"excerpt"`
	Status      pgtype.Text        `json:"status"`
	PublishedAt pgtype.Timestamptz `json:"published_at"`
	AuthorID    pgtype.UUID        `json:"author_id"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, createPost,
		arg.TenantID,
		arg.Title,
		arg.Slug,
		arg.ContentJson,
		arg.Excerpt,
		arg.Status,
		arg.PublishedAt,
		arg.AuthorID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Title,
		&i.Slug,
		&i.ContentJson,
		&i.Excerpt,
		&i.Status,
		&i.PublishedAt,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Sector,
		&i.Tags,
		&i.MetaDescription,
		&i.CustomMetaTags,
		&i.OgImageUrl,
	)
	return i, err
}

const getPost = `-- name: GetPost :one
SELECT id, tenant_id, title, slug, content_json, excerpt, status, published_at, author_id, created_at, updated_at, sector, tags, meta_description, custom_meta_tags, og_image_url FROM posts
WHERE id = $1 AND tenant_id = $2 LIMIT 1
`

type GetPostParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetPost(ctx context.Context, arg GetPostParams) (Post, error) {
	row := q.db.QueryRow(ctx, getPost, arg.ID, arg.TenantID)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Title,
		&i.Slug,
		&i.ContentJson,
		&i.Excerpt,
		&i.Status,
		&i.PublishedAt,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Sector,
		&i.Tags,
		&i.MetaDescription,
		&i.CustomMetaTags,
		&i.OgImageUrl,
	)
	return i, err
}

const listMedia = `-- name: ListMedia :many
SELECT id, tenant_id, filename, url, mime_type, size_bytes, created_at FROM media
WHERE tenant_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListMedia(ctx context.Context, tenantID pgtype.UUID) ([]Medium, error) {
	rows, err := q.db.Query(ctx, listMedia, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Medium
	for rows.Next() {
		var i Medium
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Filename,
			&i.Url,
			&i.MimeType,
			&i.SizeBytes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPages = `-- name: ListPages :many
SELECT id, tenant_id, title, slug, content_json, status, created_at, updated_at FROM pages
WHERE tenant_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListPages(ctx context.Context, tenantID pgtype.UUID) ([]Page, error) {
	rows, err := q.db.Query(ctx, listPages, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Page
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Title,
			&i.Slug,
			&i.ContentJson,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPosts = `-- name: ListPosts :many
SELECT id, tenant_id, title, slug, content_json, excerpt, status, published_at, author_id, created_at, updated_at, sector, tags, meta_description, custom_meta_tags, og_image_url FROM posts
WHERE tenant_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListPosts(ctx context.Context, tenantID pgtype.UUID) ([]Post, error) {
	rows, err := q.db.Query(ctx, listPosts, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Title,
			&i.Slug,
			&i.ContentJson,
			&i.Excerpt,
			&i.Status,
			&i.PublishedAt,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Sector,
			&i.Tags,
			&i.MetaDescription,
			&i.CustomMetaTags,
			&i.OgImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePost = `-- name: UpdatePost :one
UPDATE posts
SET title = $3, slug = $4, content_json = $5, excerpt = $6, status = $7, published_at = $8, updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, title, slug, content_json, excerpt, status, published_at, author_id, created_at, updated_at, sector, tags, meta_description, custom_meta_tags, og_image_url
`

type UpdatePostParams struct {
	ID          pgtype.UUID        `json:"id"`
	TenantID    pgtype.UUID        `json:"tenant_id"`
	Title       string             `json:"title"`
	Slug        string             `json:"slug"`
	ContentJson []byte             `json:"content_json"`
	Excerpt     pgtype.Text        `json:"excerpt"`
	Status      pgtype.Text        `json:"status"`
	PublishedAt pgtype.Timestamptz `json:"published_at"`
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, updatePost,
		arg.ID,
		arg.TenantID,
		arg.Title,
		arg.Slug,
		arg.ContentJson,
		arg.Excerpt,
		arg.Status,
		arg.PublishedAt,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Title,
		&i.Slug,
		&i.ContentJson,
		&i.Excerpt,
		&i.Status,
		&i.PublishedAt,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Sector,
		&i.Tags,
		&i.MetaDescription,
		&i.CustomMetaTags,
		&i.OgImageUrl,
	)
	return i, err
}
