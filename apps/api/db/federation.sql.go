// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: federation.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addToFederationIndex = `-- name: AddToFederationIndex :one
INSERT INTO federation_index (tenant_id, listing_id, normalized_json)
VALUES ($1, $2, $3)
RETURNING id, tenant_id, listing_id, normalized_json, last_synced_at
`

type AddToFederationIndexParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	ListingID      pgtype.UUID `json:"listing_id"`
	NormalizedJson []byte      `json:"normalized_json"`
}

func (q *Queries) AddToFederationIndex(ctx context.Context, arg AddToFederationIndexParams) (FederationIndex, error) {
	row := q.db.QueryRow(ctx, addToFederationIndex, arg.TenantID, arg.ListingID, arg.NormalizedJson)
	var i FederationIndex
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ListingID,
		&i.NormalizedJson,
		&i.LastSyncedAt,
	)
	return i, err
}

const getFederationOptIn = `-- name: GetFederationOptIn :one
SELECT tenant_id, enabled, categories_json, regions_json, created_at FROM federation_optin
WHERE tenant_id = $1
`

func (q *Queries) GetFederationOptIn(ctx context.Context, tenantID pgtype.UUID) (FederationOptin, error) {
	row := q.db.QueryRow(ctx, getFederationOptIn, tenantID)
	var i FederationOptin
	err := row.Scan(
		&i.TenantID,
		&i.Enabled,
		&i.CategoriesJson,
		&i.RegionsJson,
		&i.CreatedAt,
	)
	return i, err
}

const getFederationStats = `-- name: GetFederationStats :one
SELECT 
    (SELECT COUNT(*) FROM federation_index) as total_listings,
    (SELECT COUNT(*) FROM federation_queries) as total_queries
`

type GetFederationStatsRow struct {
	TotalListings int64 `json:"total_listings"`
	TotalQueries  int64 `json:"total_queries"`
}

func (q *Queries) GetFederationStats(ctx context.Context) (GetFederationStatsRow, error) {
	row := q.db.QueryRow(ctx, getFederationStats)
	var i GetFederationStatsRow
	err := row.Scan(&i.TotalListings, &i.TotalQueries)
	return i, err
}

const logFederationQuery = `-- name: LogFederationQuery :exec
INSERT INTO federation_queries (query, filters_json, results_count)
VALUES ($1, $2, $3)
`

type LogFederationQueryParams struct {
	Query        string `json:"query"`
	FiltersJson  []byte `json:"filters_json"`
	ResultsCount int32  `json:"results_count"`
}

func (q *Queries) LogFederationQuery(ctx context.Context, arg LogFederationQueryParams) error {
	_, err := q.db.Exec(ctx, logFederationQuery, arg.Query, arg.FiltersJson, arg.ResultsCount)
	return err
}

const searchFederationIndex = `-- name: SearchFederationIndex :many
SELECT id, tenant_id, listing_id, normalized_json, last_synced_at FROM federation_index
WHERE normalized_json->>'title' ILIKE '%' || $1::text || '%'
LIMIT 50
`

func (q *Queries) SearchFederationIndex(ctx context.Context, query string) ([]FederationIndex, error) {
	rows, err := q.db.Query(ctx, searchFederationIndex, query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FederationIndex
	for rows.Next() {
		var i FederationIndex
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ListingID,
			&i.NormalizedJson,
			&i.LastSyncedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertFederationOptIn = `-- name: UpsertFederationOptIn :one
INSERT INTO federation_optin (tenant_id, enabled, categories_json, regions_json)
VALUES ($1, $2, $3, $4)
ON CONFLICT (tenant_id) DO UPDATE
SET enabled = $2, categories_json = $3, regions_json = $4
RETURNING tenant_id, enabled, categories_json, regions_json, created_at
`

type UpsertFederationOptInParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	Enabled        bool        `json:"enabled"`
	CategoriesJson []byte      `json:"categories_json"`
	RegionsJson    []byte      `json:"regions_json"`
}

func (q *Queries) UpsertFederationOptIn(ctx context.Context, arg UpsertFederationOptInParams) (FederationOptin, error) {
	row := q.db.QueryRow(ctx, upsertFederationOptIn,
		arg.TenantID,
		arg.Enabled,
		arg.CategoriesJson,
		arg.RegionsJson,
	)
	var i FederationOptin
	err := row.Scan(
		&i.TenantID,
		&i.Enabled,
		&i.CategoriesJson,
		&i.RegionsJson,
		&i.CreatedAt,
	)
	return i, err
}
