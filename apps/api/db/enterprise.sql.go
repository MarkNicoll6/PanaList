// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: enterprise.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEnterpriseAuditLog = `-- name: CreateEnterpriseAuditLog :exec
INSERT INTO enterprise_audit_logs (tenant_id, actor_id, action, resource, details_json)
VALUES ($1, $2, $3, $4, $5)
`

type CreateEnterpriseAuditLogParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	ActorID     pgtype.UUID `json:"actor_id"`
	Action      string      `json:"action"`
	Resource    string      `json:"resource"`
	DetailsJson []byte      `json:"details_json"`
}

func (q *Queries) CreateEnterpriseAuditLog(ctx context.Context, arg CreateEnterpriseAuditLogParams) error {
	_, err := q.db.Exec(ctx, createEnterpriseAuditLog,
		arg.TenantID,
		arg.ActorID,
		arg.Action,
		arg.Resource,
		arg.DetailsJson,
	)
	return err
}

const getSCIMDirectory = `-- name: GetSCIMDirectory :one
SELECT id, tenant_id, token, enabled, created_at FROM scim_directories
WHERE tenant_id = $1
LIMIT 1
`

func (q *Queries) GetSCIMDirectory(ctx context.Context, tenantID pgtype.UUID) (ScimDirectory, error) {
	row := q.db.QueryRow(ctx, getSCIMDirectory, tenantID)
	var i ScimDirectory
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Token,
		&i.Enabled,
		&i.CreatedAt,
	)
	return i, err
}

const getSSOProvider = `-- name: GetSSOProvider :one
SELECT id, tenant_id, type, domain, metadata_url, client_id, client_secret, enabled, created_at FROM sso_providers
WHERE tenant_id = $1
LIMIT 1
`

func (q *Queries) GetSSOProvider(ctx context.Context, tenantID pgtype.UUID) (SsoProvider, error) {
	row := q.db.QueryRow(ctx, getSSOProvider, tenantID)
	var i SsoProvider
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Type,
		&i.Domain,
		&i.MetadataUrl,
		&i.ClientID,
		&i.ClientSecret,
		&i.Enabled,
		&i.CreatedAt,
	)
	return i, err
}

const listEnterpriseAuditLogs = `-- name: ListEnterpriseAuditLogs :many
SELECT id, tenant_id, actor_id, action, resource, details_json, created_at, ip, user_agent FROM enterprise_audit_logs
WHERE tenant_id = $1
ORDER BY created_at DESC
LIMIT 100
`

func (q *Queries) ListEnterpriseAuditLogs(ctx context.Context, tenantID pgtype.UUID) ([]EnterpriseAuditLog, error) {
	rows, err := q.db.Query(ctx, listEnterpriseAuditLogs, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EnterpriseAuditLog
	for rows.Next() {
		var i EnterpriseAuditLog
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ActorID,
			&i.Action,
			&i.Resource,
			&i.DetailsJson,
			&i.CreatedAt,
			&i.Ip,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertSCIMDirectory = `-- name: UpsertSCIMDirectory :one
INSERT INTO scim_directories (tenant_id, token, enabled)
VALUES ($1, $2, $3)
ON CONFLICT (id) DO UPDATE
SET token = $2, enabled = $3
RETURNING id, tenant_id, token, enabled, created_at
`

type UpsertSCIMDirectoryParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Token    string      `json:"token"`
	Enabled  bool        `json:"enabled"`
}

func (q *Queries) UpsertSCIMDirectory(ctx context.Context, arg UpsertSCIMDirectoryParams) (ScimDirectory, error) {
	row := q.db.QueryRow(ctx, upsertSCIMDirectory, arg.TenantID, arg.Token, arg.Enabled)
	var i ScimDirectory
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Token,
		&i.Enabled,
		&i.CreatedAt,
	)
	return i, err
}

const upsertSSOProvider = `-- name: UpsertSSOProvider :one
INSERT INTO sso_providers (tenant_id, type, domain, metadata_url, client_id, client_secret, enabled)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (id) DO UPDATE -- Ideally conflict on tenant_id if 1 per tenant, but schema uses UUID PK. For now insert new.
SET type = $2, domain = $3, metadata_url = $4, client_id = $5, client_secret = $6, enabled = $7
RETURNING id, tenant_id, type, domain, metadata_url, client_id, client_secret, enabled, created_at
`

type UpsertSSOProviderParams struct {
	TenantID     pgtype.UUID `json:"tenant_id"`
	Type         string      `json:"type"`
	Domain       string      `json:"domain"`
	MetadataUrl  pgtype.Text `json:"metadata_url"`
	ClientID     pgtype.Text `json:"client_id"`
	ClientSecret pgtype.Text `json:"client_secret"`
	Enabled      bool        `json:"enabled"`
}

func (q *Queries) UpsertSSOProvider(ctx context.Context, arg UpsertSSOProviderParams) (SsoProvider, error) {
	row := q.db.QueryRow(ctx, upsertSSOProvider,
		arg.TenantID,
		arg.Type,
		arg.Domain,
		arg.MetadataUrl,
		arg.ClientID,
		arg.ClientSecret,
		arg.Enabled,
	)
	var i SsoProvider
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Type,
		&i.Domain,
		&i.MetadataUrl,
		&i.ClientID,
		&i.ClientSecret,
		&i.Enabled,
		&i.CreatedAt,
	)
	return i, err
}
