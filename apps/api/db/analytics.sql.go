// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analytics.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getDailyMetrics = `-- name: GetDailyMetrics :many
SELECT tenant_id, date, pageviews, unique_visitors, outbound_clicks, search_queries_json FROM metrics_daily
WHERE tenant_id = $1 AND date >= $2 AND date <= $3
ORDER BY date
`

type GetDailyMetricsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Date     pgtype.Date `json:"date"`
	Date_2   pgtype.Date `json:"date_2"`
}

func (q *Queries) GetDailyMetrics(ctx context.Context, arg GetDailyMetricsParams) ([]MetricsDaily, error) {
	rows, err := q.db.Query(ctx, getDailyMetrics, arg.TenantID, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MetricsDaily
	for rows.Next() {
		var i MetricsDaily
		if err := rows.Scan(
			&i.TenantID,
			&i.Date,
			&i.Pageviews,
			&i.UniqueVisitors,
			&i.OutboundClicks,
			&i.SearchQueriesJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopListingsByEvents = `-- name: GetTopListingsByEvents :many
SELECT 
    l.id, l.title, l.slug,
    COUNT(le.id) as event_count
FROM listings l
JOIN listing_events le ON l.id = le.listing_id
WHERE l.tenant_id = $1 AND le.event = $2
GROUP BY l.id
ORDER BY event_count DESC
LIMIT $3
`

type GetTopListingsByEventsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Event    string      `json:"event"`
	Limit    int32       `json:"limit"`
}

type GetTopListingsByEventsRow struct {
	ID         pgtype.UUID `json:"id"`
	Title      string      `json:"title"`
	Slug       string      `json:"slug"`
	EventCount int64       `json:"event_count"`
}

func (q *Queries) GetTopListingsByEvents(ctx context.Context, arg GetTopListingsByEventsParams) ([]GetTopListingsByEventsRow, error) {
	rows, err := q.db.Query(ctx, getTopListingsByEvents, arg.TenantID, arg.Event, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopListingsByEventsRow
	for rows.Next() {
		var i GetTopListingsByEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.EventCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordListingEvent = `-- name: RecordListingEvent :one
INSERT INTO listing_events (
  tenant_id, listing_id, event, meta_json
) VALUES (
  $1, $2, $3, $4
) RETURNING id, tenant_id, listing_id, event, meta_json, created_at
`

type RecordListingEventParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	ListingID pgtype.UUID `json:"listing_id"`
	Event     string      `json:"event"`
	MetaJson  []byte      `json:"meta_json"`
}

func (q *Queries) RecordListingEvent(ctx context.Context, arg RecordListingEventParams) (ListingEvent, error) {
	row := q.db.QueryRow(ctx, recordListingEvent,
		arg.TenantID,
		arg.ListingID,
		arg.Event,
		arg.MetaJson,
	)
	var i ListingEvent
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ListingID,
		&i.Event,
		&i.MetaJson,
		&i.CreatedAt,
	)
	return i, err
}
